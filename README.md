Here is the background information on your task

With the body of your application complete, it's time to find out if it actually works. To test your microservice, we're going to be using the Cucumber framework. Cucumber is, at its heart, a technology designed to enable behaviour-driven development (BDD). BDD is a development paradigm that aims to bridge the often significant gap between the people who make the requirements and the people who implement them. The idea is to break development into a three-part cycle. First is a brainstorming session dedicated to coming up with hard and fast examples of how a new feature is going to be used. Then, those examples are translated into a special type of documentation called Gherkin syntax. Gherkin syntax is unique in that it is structured enough to be machine readable, while using plain text that humans can understand. This overlapping documentation, which both computers and executives can comprehend, is the key breakthrough boasted by Cucumber. After this, the Gherkin documentation is translated into a series of executable steps that can be run to test the application. Finally, the actual code required to pass the test is written, and the process starts all over again for the next feature. In this way, BDD shares similarities with TDD (test-driven development), since tests are outlined before the code that allows them to pass is actually developed.

By electing to use BDD with Cucumber, each feature added to a codebase ends up being well-documented in a format legible to all parties involved. Anyone approaching the codebase for the first time can immediately get a feel for what the application is capable of without reading a line of code. Furthermore, since each piece of documentation corresponds to a series of what are, in effect, integration test cases, the developers working on the project can tell when a new change breaks an old feature. In the end, developers working under the BDD paradigm have greater confidence and insight into the codebases they interact with on a daily basis.

3
Here is your task

    In order to adhere to BDD in the strictest sense, we would have had to draft our documentation (and therefore test cases) prior to actually writing our code. We've forgone this requirement for the sake of simplicity, but will still be drafting up Gherkin scenarios as if we had not. As a first step, familiarise yourself with the Cucumber framework by reading about BDD and the framework itself.
     
    Now it's time to draft some documentation. For this project, you will need to put together a single feature with two scenarios. The first scenario will be a successful SIM card activation, and the second scenario will be a failed one. The SIM card Actuator (that JAR file provided to you in the services folder to which your application submits Post requests) is designed such that the ICCID "1255789453849037777" will successfully activate, while the ICCID "8944500102198304826" will not (remember to run this JAR file while testing your code, otherwise your tests will fail ambiguously). You will need to create a scenario that submits an activation request to your microservice with the former ICCID, then uses the query endpoint (the one you added at the end of task two) to confirm that the activation was a success. Then you'll need to create a second scenario that does the same thing, but with the latter ICCID, and ensures that the activation fails.

    Hint: since the database IDs for each activation record are auto-incremented, the first record submitted to the database will have an ID of 1, while the second will have an ID of 2, and so on and so forth. Use this to your advantage when querying the database.

Since the boilerplate required to get Cucumber integrated with Spring is a bit counterintuitive, I've gone ahead and provided it with the project skeleton. Add the step definitions for your feature to the SimCardActivatorStepDefinitions class in the â€˜src/test/java/stepDefinitions' folder. Keep in mind that you can use the provided restTemplate to submit requests to your microservice (which will be running at localhost:8080).
